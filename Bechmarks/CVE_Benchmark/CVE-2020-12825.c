//CVE: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-12825
#define NULL 0
#define PRIVATE(obj) ((obj)->priv)
typedef struct _CRParserPriv {

    CRTknzr *tknzr;
    CRDocHandler *sac_handler;
    GList *err_stack;
    enum CRParserState state;
    gboolean resolve_import;
    gboolean is_case_sensitive;
    gboolean use_core_grammar;
}CRParserPriv;

typedef struct _CRParser  {
    CRParserPriv *priv ;
} CRParser;

enum CRTokenType
{
    NO_TK,
    S_TK,
    CDO_TK,
    CDC_TK,
    INCLUDES_TK,
    DASHMATCH_TK,
    COMMENT_TK,
    STRING_TK,
    IDENT_TK,
    HASH_TK,
    IMPORT_SYM_TK,
    PAGE_SYM_TK,
    MEDIA_SYM_TK,
    FONT_FACE_SYM_TK,
    CHARSET_SYM_TK,
    ATKEYWORD_TK,
    IMPORTANT_SYM_TK,
    EMS_TK,
    EXS_TK,
    LENGTH_TK,
    ANGLE_TK,
    TIME_TK,
    FREQ_TK,
    DIMEN_TK,
    PERCENTAGE_TK,
    NUMBER_TK,
    RGB_TK,
    URI_TK,
    FUNCTION_TK,
    UNICODERANGE_TK,
    SEMICOLON_TK,
    CBO_TK, /*opening curly bracket*/
    CBC_TK, /*closing curly bracket*/
    PO_TK, /*opening parenthesis*/
    PC_TK, /*closing parenthesis*/
    BO_TK, /*opening bracket*/
    BC_TK, /*closing bracket*/
    DELIM_TK
} ;

enum CRStatus {
    CR_OK,
    CR_BAD_PARAM_ERROR,
    CR_INSTANCIATION_FAILED_ERROR,
    CR_UNKNOWN_TYPE_ERROR,
    CR_UNKNOWN_PROP_ERROR,
    CR_UNKNOWN_PROP_VAL_ERROR,
    CR_UNEXPECTED_POSITION_SCHEME,
    CR_START_OF_INPUT_ERROR,
    CR_END_OF_INPUT_ERROR,
    CR_OUTPUT_TOO_SHORT_ERROR,
    CR_INPUT_TOO_SHORT_ERROR,
    CR_OUT_OF_BOUNDS_ERROR,
    CR_EMPTY_PARSER_INPUT_ERROR,
    CR_ENCODING_ERROR,
    CR_ENCODING_NOT_FOUND_ERROR,
    CR_PARSING_ERROR,
    CR_SYNTAX_ERROR,
    CR_NO_ROOT_NODE_ERROR,
    CR_NO_TOKEN,
    CR_OUT_OF_MEMORY_ERROR,
    CR_PSEUDO_CLASS_SEL_HANDLER_NOT_FOUND_ERROR,
    CR_BAD_PSEUDO_CLASS_SEL_HANDLER_ERROR,
    CR_ERROR,
    CR_FILE_NOT_FOUND_ERROR,
    CR_VALUE_NOT_FOUND_ERROR
} ;

static enum CRStatus
cr_parser_parse_any_core (CRParser * a_this)
{
    CRToken *token1 = NULL,
            *token2 = NULL;
    CRInputPos init_pos;
    enum CRStatus status = CR_ERROR;
    switch (token1->type) {
        case IDENT_TK:
        case NUMBER_TK:
        case RGB_TK:
        case PERCENTAGE_TK:
        case DIMEN_TK:
        case EMS_TK:
        case EXS_TK:
        case LENGTH_TK:
        case ANGLE_TK:
        case FREQ_TK:
        case TIME_TK:
        case STRING_TK:
        case DELIM_TK:
        case URI_TK:
        case HASH_TK:
        case UNICODERANGE_TK:
        case INCLUDES_TK:
        case DASHMATCH_TK:
        case S_TK:
        case COMMENT_TK:
        case IMPORTANT_SYM_TK:
            status = CR_OK;
            break;
        case FUNCTION_TK:
            do {
                status = cr_parser_parse_any_core (a_this);
            } while (status == CR_OK);

            ENSURE_PARSING_COND (status == CR_PARSING_ERROR);
            status = cr_tknzr_get_next_token (PRIVATE (a_this)->tknzr,
                                              &token2);
            ENSURE_PARSING_COND (status == CR_OK
                                 && token2 && token2->type == PC_TK);
            break;
        case PO_TK:
            status = cr_tknzr_get_next_token (PRIVATE (a_this)->tknzr,
                                              &token2);
            ENSURE_PARSING_COND (status == CR_OK && token2);

            if (token2->type == PC_TK) {
                cr_token_destroy (token2);
                token2 = NULL;
                goto done;
            } else {
                status = cr_tknzr_unget_token
                        (PRIVATE (a_this)->tknzr, token2);
                token2 = NULL;
            }

            do {
                status = cr_parser_parse_any_core (a_this);
            } while (status == CR_OK);

            ENSURE_PARSING_COND (status == CR_PARSING_ERROR);

            status = cr_tknzr_get_next_token (PRIVATE (a_this)->tknzr,
                                              &token2);
            ENSURE_PARSING_COND (status == CR_OK
                                 && token2 && token2->type == PC_TK);
            status = CR_OK;
            break;

        case BO_TK:
            status = cr_tknzr_get_next_token (PRIVATE (a_this)->tknzr,
                                              &token2);
            ENSURE_PARSING_COND (status == CR_OK && token2);

            if (token2->type == BC_TK) {
                cr_token_destroy (token2);
                token2 = NULL;
                goto done;
            } else {
                status = cr_tknzr_unget_token
                        (PRIVATE (a_this)->tknzr, token2);
                token2 = NULL;
            }

            do {
                status = cr_parser_parse_any_core (a_this);
            } while (status == CR_OK);

            ENSURE_PARSING_COND (status == CR_PARSING_ERROR);

            status = cr_tknzr_get_next_token (PRIVATE (a_this)->tknzr,
                                              &token2);
            ENSURE_PARSING_COND (status == CR_OK
                                 && token2 && token2->type == BC_TK);
            status = CR_OK;
            break;
        default:
            status = CR_PARSING_ERROR;
            goto error;
    }

    done:
    cr_tknzr_set_cur_pos (PRIVATE (a_this)->tknzr, &init_pos);
    return status;
}

int main(){

}