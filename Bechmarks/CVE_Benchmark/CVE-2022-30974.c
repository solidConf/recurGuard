//CVE-2022-30974
//website:https://www.cve.org/CVERecord?id=CVE-2022-30974

#define REPINF 1000
#define REG_ICASE 1
#define I_SPLIT 1
#define I_JUMP 2
#define I_BOL 3
#define I_EOL 4
#define I_WORD 5
#define I_NWORD 6
#define I_LPAR 7
#define I_RPAR 8
#define I_PLA 9
#define I_NLA 10
#define I_ANY 11
#define I_CHAR 12
#define I_CCLASS 13
#define I_NCCLASS 14
#define I_REF 15
#define I_END 16
#define P_CAT 1
#define P_ALT 2
#define P_REP 3
#define P_BOL 4
#define P_EOL 5
#define P_WORD 6
#define P_NWORD 7
#define P_PAR 8
#define P_PLA 9
#define P_NLA 10
#define P_ANY 11
#define P_CHAR 12
#define P_CCLASS 13
#define P_NCCLASS 14
#define P_REF 15
#define NULL 0
typedef struct Reinst {
    int opcode;
    int n;
    int c;
    struct Reinst **cc;
    struct Reinst *x, *y;
} Reinst;

typedef struct Reprog {
    Reinst *end;
    int flags;
} Reprog;

typedef struct Renode {
    int type;
    int m, n;
    char c;
    struct Renode *x, *y;
    struct Reinst **cc;
    int ng;
} Renode;

Reinst *emit(Reprog *prog, int opcode);
void compile(Reprog *prog, Renode *node);
void initialize(Reprog *prog);
char canon(char c);

Reinst *emit(Reprog *prog, int opcode) {
    Reinst *inst = prog->end++;
    inst->opcode = opcode;
    inst->n = 0;
    inst->c = 0;
    inst->cc = NULL;
    inst->x = inst->y = NULL;
    return inst;
}

void compile(Reprog *prog, Renode *node) {
    Reinst *inst, *split, *jump;
    int i;
    switch (node->type) {
        case P_CAT:
            compile(prog, node->x);
            compile(prog, node->y);
            break;

        case P_ALT:
            split = emit(prog, I_SPLIT);
            compile(prog, node->x);
            jump = emit(prog, I_JUMP);
            compile(prog, node->y);
            split->x = split + 1;
            split->y = jump + 1;
            jump->x = prog->end;
            break;

        case P_REP:
            inst = NULL;
            for (i = 0; i < node->m; ++i) {
                inst = prog->end;
                compile(prog, node->x);
            }
            break;

        case P_BOL: emit(prog, I_BOL); break;
        case P_EOL: emit(prog, I_EOL); break;
        case P_WORD: emit(prog, I_WORD); break;
        case P_NWORD: emit(prog, I_NWORD); break;
        case P_PAR:
            inst = emit(prog, I_LPAR);
            inst->n = node->n;
            compile(prog, node->x);
            inst = emit(prog, I_RPAR);
            inst->n = node->n;
            break;

        case P_PLA:
            split = emit(prog, I_PLA);
            compile(prog, node->x);
            emit(prog, I_END);
            split->x = split + 1;
            split->y = prog->end;
            break;

        case P_NLA:
            split = emit(prog, I_NLA);
            compile(prog, node->x);
            emit(prog, I_END);
            split->x = split + 1;
            split->y = prog->end;
            break;

        case P_ANY:
            emit(prog, I_ANY);
            break;

        case P_CHAR:
            inst = emit(prog, I_CHAR);
            inst->c = (prog->flags & REG_ICASE) ? canon(node->c) : node->c;
            break;

        case P_CCLASS:
            inst = emit(prog, I_CCLASS);
            inst->cc = node->cc;
            break;

        case P_NCCLASS:
            inst = emit(prog, I_NCCLASS);
            inst->cc = node->cc;
            break;

        case P_REF:
            inst = emit(prog, I_REF);
            inst->n = node->n;
            break;

        default:
            break;
    }
}

void initialize(Reprog *prog) {
    prog->end = malloc(sizeof(Reinst) * 100);
    prog->flags = 0;
}

char canon(char c) {
    return c;
}

Renode* createCyclicNode() {
    Renode* node = malloc(sizeof(Renode));
    node->type = P_CAT; // 使用 P_CAT 类型
    node->x = node; // 使节点的 x 指向自身
    node->y = NULL; // y 为 NULL
    node->m = 0;
    node->n = 1; // 可以设置为任意值
    node->c = 0;
    node->ng = 0;
    node->cc = NULL;
    return node;
}

int main() {
    Reprog prog;
    initialize(&prog);

    Renode* root = createCyclicNode(); // 创建一个循环节点
    compile(&prog, root); // 调用编译

    // Free allocated resources (not shown here)
    // 由于存在无限递归，实际的释放代码不会被执行

    return 0;
}
