//CVE-2022-1771
// Created by zy on 24-3-11.
//https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=CVE-2022-1771
# define OK			1
#define FAIL			0


static void
save_cmdline(cmdline_info_T *ccp)
{
    if (!prev_ccline_used)
    {
        CLEAR_FIELD(prev_ccline);
        prev_ccline_used = TRUE;
    }
    *ccp = prev_ccline;
    prev_ccline = ccline;
    ccline.cmdbuff = NULL;  // signal that ccline is not in use
}

static void alloc_cmdbuff(int len)
{
    /*
     * give some extra space to avoid having to allocate all the time
     */
    if (len < 80)
        len = 100;
    else
        len += 20;

    cmdbuff = alloc(len);    // caller should check for out-of-memory
}

int
init_ccline(int firstc, int indent)
{
    return OK;
}

static char_u *
getcmdline_int(
        int		firstc,
        long	count UNUSED,	// only used for incremental search
        int		indent,		// indent for inside conditionals
        int		clear_ccline)	// clear ccline first
{

    if (ccline.cmdbuff != NULL)
    {
        // Being called recursively.  Since ccline is global, we need to save
        // the current buffer and restore it when returning.
        save_cmdline(&save_ccline);
        did_save_ccline = TRUE;
    }
    if (clear_ccline)
        CLEAR_FIELD(ccline);


    if (init_ccline(firstc, indent) != OK)
        goto theend;

    theend:
    {
        char_u *p = ccline.cmdbuff;

        if (did_save_ccline)
            restore_cmdline(&save_ccline);
        else
            ccline.cmdbuff = NULL;
        return p;
    }
}