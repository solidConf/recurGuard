//CVE-2022-30974
//website:

static void compile(Reprog *prog, Renode *node)
{
    Reinst *inst, *split, *jump;
    int i;

    loop:
    if (!node)
        return;

    switch (node->type) {
        case P_CAT:
            compile(prog, node->x);
            node = node->y;
            goto loop;

        case P_ALT:
            split = emit(prog, I_SPLIT);
            compile(prog, node->x);
            jump = emit(prog, I_JUMP);
            compile(prog, node->y);
            split->x = split + 1;
            split->y = jump + 1;
            jump->x = prog->end;
            break;

        case P_REP:
            inst = NULL; /* silence compiler warning. assert(node->m > 0). */
            for (i = 0; i < node->m; ++i) {
                inst = prog->end;
                compile(prog, node->x);
            }
            if (node->m == node->n)
                break;
            if (node->n < REPINF) {
                for (i = node->m; i < node->n; ++i) {
                    split = emit(prog, I_SPLIT);
                    compile(prog, node->x);
                    if (node->ng) {
                        split->y = split + 1;
                        split->x = prog->end;
                    } else {
                        split->x = split + 1;
                        split->y = prog->end;
                    }
                }
            } else if (node->m == 0) {
                split = emit(prog, I_SPLIT);
                compile(prog, node->x);
                jump = emit(prog, I_JUMP);
                if (node->ng) {
                    split->y = split + 1;
                    split->x = prog->end;
                } else {
                    split->x = split + 1;
                    split->y = prog->end;
                }
                jump->x = split;
            } else {
                split = emit(prog, I_SPLIT);
                if (node->ng) {
                    split->y = inst;
                    split->x = prog->end;
                } else {
                    split->x = inst;
                    split->y = prog->end;
                }
            }
            break;

        case P_BOL: emit(prog, I_BOL); break;
        case P_EOL: emit(prog, I_EOL); break;
        case P_WORD: emit(prog, I_WORD); break;
        case P_NWORD: emit(prog, I_NWORD); break;

        case P_PAR:
            inst = emit(prog, I_LPAR);
            inst->n = node->n;
            compile(prog, node->x);
            inst = emit(prog, I_RPAR);
            inst->n = node->n;
            break;
        case P_PLA:
            split = emit(prog, I_PLA);
            compile(prog, node->x);
            emit(prog, I_END);
            split->x = split + 1;
            split->y = prog->end;
            break;
        case P_NLA:
            split = emit(prog, I_NLA);
            compile(prog, node->x);
            emit(prog, I_END);
            split->x = split + 1;
            split->y = prog->end;
            break;

        case P_ANY:
            emit(prog, I_ANY);
            break;
        case P_CHAR:
            inst = emit(prog, I_CHAR);
            inst->c = (prog->flags & REG_ICASE) ? canon(node->c) : node->c;
            break;
        case P_CCLASS:
            inst = emit(prog, I_CCLASS);
            inst->cc = node->cc;
            break;
        case P_NCCLASS:
            inst = emit(prog, I_NCCLASS);
            inst->cc = node->cc;
            break;
        case P_REF:
            inst = emit(prog, I_REF);
            inst->n = node->n;
            break;
    }
}

int main(){

}